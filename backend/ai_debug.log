Testing generate_quiz...
Quiz Success!
{'title': 'Basic Quiz: React hooks', 'topic': 'React hooks', 'difficulty': 'Basic', 'time_limit': 10, 'questions': [{'question': 'You are building a simple counter component. Which of the following lines correctly updates the `count` state variable to increment its value by 1 when a button is clicked, following best practices for `useState`?', 'options': ['A. `setCount(count + 1);`', 'B. `setCount(prevCount => prevCount + 1);`', 'C. `count = count + 1;`', 'D. Both A and B are equally good and correct.'], 'correct_answer': 'D. Both A and B are equally good and correct.', 'explanation': "Both `setCount(count + 1)` and `setCount(prevCount => prevCount + 1)` will correctly increment the counter. Option A uses the current `count` value from the closure, which is usually fine if the update is not batched or asynchronous with other state updates. Option B uses the functional update form, which is generally preferred when the new state depends on the previous state, as it guarantees you are working with the most recent state value. For a simple increment, both work, but B is safer in more complex scenarios. Option C directly modifies the state variable, which is a violation of React's immutability principle and will not trigger a re-render.", 'id': 1, 'type': 'mcq_single'}, {'question': 'You are building a search input component that needs to log a message to the console every time the `searchTerm` state changes. Which dependency array for the `useEffect` hook would achieve this behavior?', 'options': ['A. `[]`', 'B. `[searchTerm]`', 'C. `[setSearchTerm]`', 'D. No dependency array'], 'correct_answer': 'B. `[searchTerm]`', 'explanation': "An empty dependency array (`[]`) causes the effect to run only once after the initial render. No dependency array (omitted) causes the effect to run after every render. Including `setSearchTerm` in the dependency array is usually unnecessary as setter functions are stable across renders. By including `[searchTerm]`, the `useEffect` hook will re-run its callback function only when the `searchTerm` value changes, which is precisely what's needed to log the message upon state change.", 'id': 2, 'type': 'mcq_single'}, {'question': 'You need to store a reference to a DOM element (e.g., an input field) in a functional component so you can imperatively focus it later. You also want this reference to persist across re-renders without causing the component to re-render when the reference changes. Which React Hook is the most appropriate for this task?', 'options': ['A. `useState`', 'B. `useEffect`', 'C. `useRef`', 'D. `useContext`'], 'correct_answer': 'C. `useRef`', 'explanation': "`useRef` returns a mutable ref object whose `.current` property can hold any mutable value. It's commonly used to access DOM elements directly or to store any mutable value that needs to persist across renders without triggering a re-render when its value changes. `useState` would cause a re-render on value change, `useEffect` is for side effects, and `useContext` is for consuming context.", 'id': 3, 'type': 'mcq_single'}, {'question': 'Consider a React component that subscribes to a global event listener when it mounts. Which of the following code snippets correctly demonstrates how to clean up this event listener to prevent memory leaks when the component unmounts?', 'options': ["A. `useEffect(() => { window.addEventListener('scroll', handleScroll); window.removeEventListener('scroll', handleScroll); }, []);`", "B. `useEffect(() => { window.addEventListener('scroll', handleScroll); }, [handleScroll]); // Rely on garbage collection`", "C. `useEffect(() => { const handleScroll = () => {}; window.addEventListener('scroll', handleScroll); return () => { window.removeEventListener('scroll', handleScroll); }; }, []);`", 'D. `// No cleanup needed, React handles global event listeners automatically`'], 'correct_answer': "C. `useEffect(() => { const handleScroll = () => {}; window.addEventListener('scroll', handleScroll); return () => { window.removeEventListener('scroll', handleScroll); }; }, []);`", 'explanation': 'To prevent memory leaks, side effects like adding event listeners must be cleaned up. `useEffect` allows you to return a cleanup function. This function is executed when the component unmounts, or before the effect runs again if its dependencies change. Option C correctly sets up the listener and returns a function that removes it, ensuring proper cleanup. Options A and B do not correctly handle cleanup, and D is incorrect as React does not automatically clean up global event listeners.', 'id': 4, 'type': 'mcq_single'}, {'question': "According to the 'Rules of Hooks', which of the following code snippets correctly uses a React Hook?", 'options': ['A. `function MyComponent() { if (condition) { const [count, setCount] = useState(0); } }`', 'B. `function MyComponent() { for (let i = 0; i < 5; i++) { const [value, setValue] = useState(i); } }`', 'C. `const MyHook = () => { const [data, setData] = useState([]); return data; }`', "D. `function MyComponent() { const [name, setName] = useState('React'); function handleClick() { const [clicked, setClicked] = useState(false); } }`"], 'correct_answer': 'C. `const MyHook = () => { const [data, setData] = useState([]); return data; }`', 'explanation': "The 'Rules of Hooks' state that hooks must be called from the top level of a React functional component or a custom hook, and not from inside loops, conditions, or nested functions. Options A, B, and D violate these rules by calling `useState` inside a conditional statement (`if`), a loop (`for`), or a nested function (`handleClick`), respectively. Option C demonstrates a correct usage within a custom hook, which is an allowed context for calling other hooks.", 'id': 5, 'type': 'mcq_single'}]}

Testing generate_assignment...
Assignment Success!
{'title': 'React Hooks: Simple State Management with `useState`', 'type': 'coding', 'difficulty': 'Basic', 'instructions': "**Problem Statement:**\n**Practical Task: Interactive Counter Component**\nCreate a functional React component named `SimpleCounter`. This component should display a number and include two buttons: one to increment the number and one to decrement the number. The number should start at 0.\n\n**Conceptual Question: Understanding `useState`'s Purpose**\nBriefly explain the primary purpose of the `useState` hook in React functional components. How does it enable state management in functions where it wasn't traditionally possible?\n\n**Requirements:**\n- Implement `SimpleCounter` as a functional React component.\n- Use the `useState` hook to manage the counter's value.\n- The component must render the current count prominently.\n- Include two `<button>` elements: one labeled 'Increment' and one labeled 'Decrement'.\n- Clicking 'Increment' should increase the count by 1.\n- Clicking 'Decrement' should decrease the count by 1.\n- For the conceptual question, provide a concise explanation (1-3 sentences).\n\n**Constraints:**\n- Use only core React APIs (no external state management libraries).\n- The solution for the practical task must be a single functional component.\n- No class components are allowed.\n\n**Expected Output:**\nFor the practical task: A runnable React application demonstrating the `SimpleCounter` component. Users can interact with 'Increment' and 'Decrement' buttons, and the displayed number updates accordingly.\nFor the conceptual question: A clear, concise text explanation addressing the purpose of `useState`.", 'expected_deliverables': 'Code submission', 'evaluation_criteria': "**Correctness of `useState` Usage (Practical Task)**: Is `useState` correctly initialized and updated within the component?, **Component Functionality (Practical Task)**: Do the increment and decrement buttons work as expected, updating the displayed count correctly?, **Code Readability & Structure (Practical Task)**: Is the code well-organized, easy to understand, and follows standard React practices?, **Accuracy and Conciseness of Explanation (Conceptual Question)**: Is the explanation for `useState`'s purpose accurate, to the point, and clearly articulated?"}
